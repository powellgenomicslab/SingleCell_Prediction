---
title: "prediction"
author: "Jose Alquicira Hernandez"
date: "11 May 2017"
output: html_document
---

```{r setup, include=FALSE, echo=FALSE}
require("knitr")
opts_knit$set(root.dir = "/Users/j.alquicira/Documents/powell_lab/projects/cell_prediction")
```


```{r load_libraries}
library('glmnet')
library('foreach')
library('doParallel')
library('dplyr')
```


```{r command_line_args, eval=FALSE}
# argv <- commandArgs(TRUE)
# cluster.ID <- argv[1]
# day.ID <- argv[2]
```


```{r set_variables}
# Set variables
cluster.ID <- 1
day.ID <- 2
```



```{r setwd}
# setwd('/Users/j.alquicira/Documents/powell_lab/projects/cell_prediction')
```


# Read data

- `expression.data` corresponds to a gene expression matrix. Rows are *genes* and columns are *cells*
- `cell.clusters` is a vector. Each value corresponds to one cluster. The length of the vector is the total of cell


```{r read_data}
expression.data <- readRDS('ori_dat_sample.RDS')
cell.clusters <- readRDS('my.clusters_0.45_Day2.RDS')

# expression.data <- readRDS(paste0("Exprs_DCVLnorm_unlog_minus1_pos_Day", day.ID, ".RDS"))
# cell.clusters <- readRDS(paste0("my.clusters_0.45_Day",day.ID, ".RDS"))
```

```{r show_unique_clusters}
cat("Clusters:\n")
cat(sort(unique(cell.clusters)))
cat("\n")
```

```{r format_gene_names}
rownames(expression.data) <- gsub("_.*", '', rownames(expression.data))
```


```{r get_cluster_ids}
n.clusters <- length(unique(cell.clusters))
```


```{r define_clusters}
## `cluster_select` contains indexes of all cluster tags that are equal to the cluster to be evaluated
cluster.select <- which(cell.clusters == as.numeric(cluster.ID))

## `cluster_compare` contains indexes of remaining cluster tags to be compared
cluster.compare <- which(cell.clusters != as.numeric(cluster.ID))
```


```{r cell-cluster_classification}
## cell.ids.cluster is a dataframe with two columns:
### 1. Cell id
### 2. Assigned cluster
cell.ids.cluster <- cbind(colnames(expression.data), cell.clusters)
```


```{r read_DEdata}
# Read differentially expressed data
# DE.genes <- read.table(paste0('DEseq_Cluster', cluster.ID, '_vs_OtherClusters_Day', day.ID,'.txt_filtered_pAdjusted_sorted.txt'), header = TRUE)
DE.genes <- readRDS('DE_result_sample.RDS')

# Gets gene names from `DE_result` and gets indexes of differential expressed genes in `expression.data` 
DE.gene.names <- gsub("_.*", '',  DE.genes$id)
DE.gene.idx <- which(rownames(expression.data) %in% DE.gene.names)
```



# Run regularization method

```{r init_params}
# Assign values to variables
clusterID.select <- '1'
clusterID.comp <- '2'
features <- DE.gene.idx
```


# `BuildPredictor` function

## Parameters

- `clusterID.select`: ID of cluster of interest
- `cluster.select`: Indexes of cells from cluster of interest
- `clusterID.comp`: ID of cluster to be compared
- `cluster.compare`: Indexes of cells from cluster of interest
- `features`: Indexes for features to be included in the model (list of genes of interes, differentially expressed genes)
- `expression.data`: Gene expression matrix
  + Rows: genes
  + Columns: cells

## Output


```{r define_BuildTrainTest}

BuildTrainTest <- function(clusterID.select, cluster.select, clusterID.comp, cluster.compare, features, expression.data){
  
  # Random sampling for training data --------------------------------------
  # Take random sample of cells corresponding to cluster of interest
  cluster.select.indx <- sample(cluster.select, 
                                size = round(length(cluster.select)/2), 
                                replace = FALSE)
  # Take random sample of cells corresponding to cluster to be compared
  cluster.compare.indx <- sample(cluster.compare, 
                                 size = round(length(cluster.compare)/2), 
                                 replace = FALSE)
  
  # Build predictor matrix -------------------------------------------------
  # Prepare predictor matrix containing both clutering classes
  predictor <- expression.data[features, c(cluster.select.indx, cluster.compare.indx)]
  
  # Generate categorical response ------------------------------------------
  # Set all values to cluster of interest
  response <- rep(clusterID.select, ncol(predictor))
  cluster.compare.names <- colnames(expression.data[,cluster.compare])
  sub.clustercompare.indx <- which(colnames(predictor) %in% cluster.compare.names)
  
  # Replace values for cluster.compare
  response[sub.clustercompare.indx] <- rep(clusterID.comp, length(sub.clustercompare.indx))

  # tranpose prediction matrix
  predictor <- t(predictor)
  
  # Random sampling for testing data ---------------------------------------
  # Prepare validation test. keep all cells except for those used in the training set
  cluster.select.indx.val <- sample(cluster.select[-cluster.select.indx])
  cluster.compare.indx.val <- sample(cluster.compare[-cluster.compare.indx])
  test <- expression.data[features, c(cluster.select.indx.val , cluster.compare.indx.val)]
  test <- t(test)
  
  # Return results ---------------------------------------------------------
  return(list(training = predictor, test = test, response = response))
}
```


```{r}
data.train.test <- BuildTrainTest(clusterID.select = cluster.ID, 
               cluster.select = cluster.select, 
               clusterID.comp = 2, 
               cluster.compare = cluster.compare, 
               features = DE.gene.idx, 
               expression.data = expression.data)

str(data.train.test)
```



# `FitRegModel` function

## Parameters

- `predictor`: gene expression matrix used as predictor
- `response`: vector of categorical values
- `clusterID.select`: ID of cluster of interest
- `cluster.select`: Indexes of cells from cluster of interest
- `clusterID.comp`: ID of cluster to be compared
- `cluster.compare`: Indexes of cells from cluster of interest

```{r}
# Initialize variables
test <- data.train.test$test
training <- data.train.test$training
response <- data.train.test$response
```



```{r}
FitRegModel <- function(test, training, response, ...){
  
  # Fit model
  fit <- glmnet(x = training, 
                y = response, 
                ...)
  
  # Fitting with cross validation
  cvfit <- cv.glmnet(x = training, 
                     y = response, 
                     type.measure = "class", ...)
  
  # Extract Beta coefficients using an optimized lambda value 
  cvfit.out <- as.data.frame(as.matrix(coef(cvfit, s = cvfit$lambda.min)))
  
  #find genes with coefficient different to 0
  cvfit.out$name <- row.names(cvfit.out)
  sub.cvfit.out <- cvfit.out[cvfit.out$`1` != 0,]
  
  # Extract explained deviance
  temp <- capture.output(cvfit.dev <- as.data.frame(as.matrix(print(cvfit$glmnet.fit))))
  names(cvfit.dev) <- c('df', 'deviance', 'lambda')
  
  # Get the coordinate for lambda that produces minimum error 
  cvfit.dev.lambda.idx <- which(round(cvfit.dev$lambda,digit = 3) == round(cvfit$lambda.min,digits = 3))
  cvfit.dev <- cvfit.dev[1:cvfit.dev.lambda.idx[1],]
  
  
  # Get max deviance for each degree of freedom level
  require(dplyr)
  
  cvfit.dev %>% 
    group_by(df) %>% 
    summarise(deviance = max(deviance)) %>% 
    as.data.frame() -> cvfit.dev.max
  
  
  cvfit.dev.max$DEgenes <- paste0('DEgenes_C', cluster.ID, '_day_', day.ID)
  remaining <- c('remaining', 1, 'DEgenes')
  cvfit.dev.max <- rbind(cvfit.dev.max, remaining)
  
  
  # Predict clusters ysing cvfit and testing dataset
  predict.clusters <- predict(cvfit, 
                              newx = test, 
                              type = "class",
                              s = cvfit$lambda.min)
  
  # Return output
  return(list(prediction = predict.clusters, sub.cvfit.out = sub.cvfit.out, cvfit.dev.max = cvfit.dev.max, cvfit = cvfit))
  
}
```


```{r}
lasso <- FitRegModel(test, training, response, family = "binomial", alpha = 1)
ridge <- FitRegModel(test, training, response, family = "binomial", alpha = 0)
elastic.net <- FitRegModel(test, training, response, family = "binomial", alpha = 0.5)
```


```{r}
# Set the character values (one of the two classes) for the response variable
cluster.compareID <- seq_len(length(unique(cell.ids.cluster)))
cluster.compareID <- paste0(cluster.compareID[-which(cluster.compareID == cluster.ID)], collapse = "")
predict.marker <- FitRegModel(test, training, response, family = "binomial", alpha = 1)
prediction <- predict.marker$prediction

# Compare to original clutering classes to check for accuracy
predict.index <- which(cell.ids.cluster[,1] %in% row.names(training))

original.cluster <- cell.ids.cluster[predict.index,]
original.cluster <- original.cluster[order(original.cluster[,2], decreasing = TRUE),]
original.cluster <- as.data.frame(original.cluster)
predict.clusters <- as.data.frame(prediction)
predict.clusters$cellnames <- row.names(predict.clusters)
compare <- merge(original.cluster, predict.clusters, by.x = 'V1', by.y = 'cellnames')

# Change cluster IDs here
cluster.select.predict <- subset(compare, (as.numeric(compare$cell.clusters) == cluster.ID &  compare$`1`==cluster.ID) | (compare$cell.clusters != cluster.ID &  compare$`1`!=cluster.ID))

accurate <- nrow(cluster.select.predict)
inaccurate <- nrow(compare) - nrow(cluster.select.predict)
list.acc.inacc <- list(accurate, inaccurate)
#Return the list for the combine function during the parallelisation process
return(list(list.acc.inacc = list.acc.inacc, list.sig.genes = predict.marker$sub.cvfit.out, list.deviance = predict.marker$cvfit.dev.max, list.cvFit = predict.marker$cvfit)) 

```




```{r}
comb <- function(x, ...) {
  lapply(seq_along(x),
    function(i) c(x[[i]], lapply(list(...), function(y) y[[i]])))
}

n_cores <- 5
cl <- makeCluster(n_cores) # create a cluster
registerDoParallel(cl) # register the cluster

#for DE genes
All_List <- foreach (i = 1:100,.combine=comb,.multicombine=TRUE,.init=list(list(), list(), list(), list()),.packages = "glmnet") %dopar% {
#set the character values (one of the two classes) for the response variable  
              c_compareID = 1:length(unique(my.clusters))
              c_compareID <- paste0(c_compareID[-which(c_compareID==c_selectID)], collapse="")
              predict_marker<- FitRegModel(cluster_select,c_selectID=c_selectID, cluster_compare, c_compareID, M_or_DE_idx=DE_idx)
              predictor_S2_name <-predict_marker[[2]]
              predict_label <-predict_marker[[1]]
              #from here compare to original clusering classes to check for accuracy
              predict_index <-which(cellNames_cluster[,1] %in% row.names(predictor_S2_name))
              original_cluster <- cellNames_cluster[predict_index,]
              original_cluster <-original_cluster[order(original_cluster[,2], decreasing = T),]
              original_cluster <-as.data.frame(original_cluster)
              predict_clusters <-as.data.frame(predict_label)
              predict_clusters$cellnames <-row.names(predict_clusters)
              compare <-merge(original_cluster, predict_clusters, by.x='V1', by.y='cellnames')
              #change cluster IDs here
              cluster_select_predict <- subset(compare, (as.numeric(compare$my.clusters) == c_selectID &  compare$`1`==c_selectID) | (compare$my.clusters!=c_selectID &  compare$`1`!=c_selectID))
              accurate <-dim(cluster_select_predict)[1]
              inaccurate <-dim(compare)[1] - dim(cluster_select_predict)[1]
              list_acc_inacc <-list(accurate, inaccurate)
	      #Return the list for the combine function during the parallelisation process
	      return(list(list_acc_inacc=list_acc_inacc, list_SigGenes=predict_marker[[3]],list_Deviance=predict_marker[[4]],list_cvFit=predict_marker[[5]])) 
}

saveRDS(All_List, file=paste0('All_List_c', c_selectID, 'vs_Remaining_Day',dayID,'_Testing.RDS'))
cat('Done Boostrap DEgenes')


stopCluster(cl)

```


